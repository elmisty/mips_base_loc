#!/bin/sh
. /etc/functions.sh
include /lib/config

## For Multi-WAN
#proto=`uci get network.wan.proto`
#if [ "$proto" == "pppoe" ] || [ "$proto" == "pptp" ];then
#	WAN="$proto"-wan
#else
#	WAN=`uci get network.wan.ifname`
#fi

LAN="br+"

#dos_enable=$(uci_get firewall general dos_enable)
#nat_enable=$(uci_get nat general nat)
#upnp_enable=$(uci_get upnpd config enabled)
icmp_ping=$(uci_get firewall6 general pingEnabled)
#parental_enable=$(uci_get parental keyword enable)
firewall_enable=$(uci_get firewall6 general filterEnabled)
firewall_rule_count=$(uci_get firewall6 general rules_count)
#sessions_user=$(uci_get nat general sessions_user)
#igmpproxy_enable=$(uci_get igmpproxy general igmpEnabled)


## reload icmp ping
ip6tables -D INPUT -p ipv6-icmp -j input_icmp
ip6tables -D FORWARD -p ipv6-icmp -j forwarding_icmp

### insert ping filter on FORWARD chain (firewall need to be prior to icmp ping filter)
ip6tables -I FORWARD -p ipv6-icmp -j forwarding_icmp

## reload NAT related
#ip6tables -D FORWARD -j forwarding_rule_nat 2>/dev/null
#ip6tables -D FORWARD -j forwarding_rule_porttrigger 2>/dev/null

#if [ "$nat_enable" == "enable" ]; then
#	ip6tables -I FORWARD -j forwarding_rule_nat 2>/dev/null
#	ip6tables -I FORWARD -j forwarding_rule_porttrigger 2>/dev/null
#fi

## reload firewall chain (firewall need to be prior to icmp ping filter)
ip6tables -D INPUT -j input_rule 2>/dev/null
ip6tables -D FORWARD -j forwarding_rule_filter 2>/dev/null

if [ "$firewall_enable" == "1" ]; then
	ip6tables -A INPUT -j input_rule
	ip6tables -I FORWARD -j forwarding_rule_filter
fi

### insert ping filter on INPUT chain (firewall need to be prior to icmp ping filter)
ip6tables -A INPUT -p ipv6-icmp -j input_icmp

## reload upnp 
#iptables -D FORWARD ! -i $LAN -o $LAN -j MINIUPNPD
#if [ "$upnp_enable" == "1" ]; then
#	iptables -I FORWARD ! -i $LAN -o $LAN -j MINIUPNPD
#fi

## reload DoS chain
#iptables -D INPUT -j DOS_INPUT 2>/dev/null
#iptables -D FORWARD -j DOS_FORWARD 2>/dev/null
#iptables -t mangle -D PREROUTING -j DOS_LAND_ATTACK_LOG 2>/dev/null

#if [ "$dos_enable" == "1" ]; then
#	iptables -I INPUT -j DOS_INPUT 2>/dev/null
#	iptables -I FORWARD -j DOS_FORWARD 2>/dev/null
#	iptables -t mangle -I PREROUTING -j DOS_LAND_ATTACK_LOG 2>/dev/null
#fi

##set for tr069
#iptables -D INPUT -j RMMG_TR069 2>/dev/null
#iptables -I INPUT -j RMMG_TR069 2>/dev/null

##check mode,only router mode have igmpproxy
#local sys_mode=$(get_sys_mode)

#[ "$sys_mode" == "1" ] && {
## reload multicast bypass rule
#iptables -D FORWARD -p udp ! -i $LAN -d 224.0.0.0/240.0.0.0 -j ACCEPT
#iptables -N input_igmp 2>/dev/null
#iptables -F input_igmp 2>/dev/null
#iptables -D INPUT -j input_igmp 2>/dev/null
#if [ "$igmpproxy_enable" == "enable" ]; then
#	iptables -I FORWARD -p udp ! -i $LAN -d 224.0.0.0/240.0.0.0 -j ACCEPT
#	iptables -A input_igmp -p igmp ! -i $LAN -d 224.0.0.1 -j ACCEPT
#	iptables -A input_igmp -p igmp ! -i $LAN -d 224.0.0.2 -j ACCEPT
#	iptables -A INPUT -j input_igmp 
#fi
#}

## reload SPI
ip6tables -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ip6tables -D INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
ip6tables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ip6tables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

## reload parental control
#iptables -D FORWARD -j web_filter

#filter_activeX=$(uci_get parental restrict_web activeX)
#filter_java=$(uci_get parental restrict_web java)
#filter_cookies=$(uci_get parental restrict_web cookies)
#filter_web_proxy=$(uci_get parental restrict_web web_proxy)
#filter_sum=$(( $filter_activeX+$filter_java+$filter_cookies+$filter_web_proxy ))

#if [ "$parental_enable" == "1" -o $filter_sum -gt 0 ]; then
#	iptables -I FORWARD -j web_filter
#fi

## reload TCPMSS
#iptables -D FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
#iptables -I FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu

## reload vpn releated 
#/sbin/netbios_daemon reload

## relaod nat session limit
#iptables -D FORWARD -j forwarding_session_limit 
#if [ "$sessions_user" != "" ]; then
#	iptables -I FORWARD -j forwarding_session_limit
#fi

## VPN bypass rule
#iptables -D INPUT -j input_vpn
#iptables -D FORWARD -j forward_vpn
#vpn_check=$(cat /var/psk.txt)

#if [ -n "$vpn_check" ]; then
#	iptables -A INPUT -j input_vpn
#	iptables -A FORWARD -j forward_vpn
#fi

## lan and local traffic must be accept by default, if there is exception rule, the default action will be ACCEPT
ip6tables -D INPUT -j lan_local_default
ip6tables -D FORWARD -i $LAN -j ACCEPT
ip6tables -D INPUT -j ACCEPT
ip6tables -D FORWARD -j ACCEPT

if [ "$firewall_enable" == "1" ]; then
	if [ $firewall_rule_count -eq 0 ]; then
		ip6tables -A INPUT -j lan_local_default
		ip6tables -A FORWARD -i $LAN -j ACCEPT
	else
		ip6tables -A INPUT -j ACCEPT
		ip6tables -A FORWARD -j ACCEPT
	fi
else
	ip6tables -A INPUT -j lan_local_default
	ip6tables -A FORWARD -i $LAN -j ACCEPT
fi

##set remote MGMT Rule
#iptables -D INPUT -j RMMG_WWW_INPUT 2>/dev/null
#iptables -I INPUT -j RMMG_WWW_INPUT 2>/dev/null
#iptables -D INPUT -j RMMG_TELNET_INPUT 2>/dev/null
#iptables -I INPUT -j RMMG_TELNET_INPUT 2>/dev/null

##set for SNMP
#iptables -D INPUT -j RMMG_SNMP 2>/dev/null
#iptables -I INPUT -j RMMG_SNMP 2>/dev/null

##set for 
#iptables -D FORWARD -j IntfGrp 2>/dev/null
#iptables -I FORWARD -j IntfGrp 2>/dev/null

#guest wireless LAN
#/lib/firewall/firewall_guest_wlan



#iptables -t filter -F SNMPchain
#iptables -t filter -F SNMPchain2

